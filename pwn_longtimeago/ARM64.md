# ARM64

ARM、x86指的是两种不同的架构，这些架构是微处理器执行的指令集。比如说我们常看的x64上和arrch64的程序反汇编下所用的汇编指令就不同，寄存器也不同（汇编指令并不等价于机器指令）。换句话说，就是我们即便给了它相同的c源码，它们的实现方式也不同。

ARM处理器用到的指令集分为 ARM 和 THUMB 两种。ARM指令长度固定为32bit，THUMB指令长度固定为16bit。所以 ARM64指令集的指令长度为32bit

字（Word）：32位系统字长就是32,64位系统字长就是64。`stdint.h`文件中定义了宏`__WORDSIZE`表示字的位数:

## 寄存器

ARM64 有34个寄存器，包括31个通用寄存器、SP、PC、CPSR

| 寄存器  | 位数  | 描述                                                         |
| ------- | ----- | ------------------------------------------------------------ |
| x0-x30  | 64bit | 通用寄存器，如果有需要可以当做32bit使用：WO-W30              |
| FP(x29) | 64bit | 保存栈帧地址(栈底指针)                                       |
| LR(x30) | 64bit | 通常称X30为程序链接寄存器，保存子程序结束后需要执行的下一条指令 |
| SP      | 64bit | 保存栈指针,使用 SP/WSP来进行对SP寄存器的访问。               |
| PC      | 64bit | 程序计数器，俗称PC指针，总是指向即将要执行的下一条指令,在arm64中，软件是不能改写PC寄存器的。 |
| CPSR    | 64bit | 状态寄存器                                                   |

x0-x7: 用于子程序调用时的参数传递，X0还用于返回值传递

`x0 - x30` 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 当使用 `x0 - x30` 访问时，它就是一个64位的数。当使用 `w0 - w30` 访问时，访问的是这些寄存器的低32位

CPSR可以类比x64下的flag寄存器，pc可以类比一下ip寄存器，lr当作返回地址（与x64不同，人家用寄存器传返回地址，而不是栈）fp对照rbp，sp对照rsp，这只是类比，并不是说完全一样

## 指令

常用到的指令：

```css
MOV    X1，X0         ;将寄存器X0的值传送到寄存器X1
ADD    X0，X1，X2     ;寄存器X1和X2的值相加后传送到X0
SUB    X0，X1，X2     ;寄存器X1和X2的值相减后传送到X0

AND    X0，X0，#0xF    ; X0的值与0xF相位与后的值传送到X0
ORR    X0，X0，#9      ; X0的值与9相位或后的值传送到X0
EOR    X0，X0，#0xF    ; X0的值与0xF相异或后的值传送到X0

LDR    X5，[X6，#0x08]        ；ld：load; X6寄存器加0x08的和的地址值内的数据传送到X5
LDP  x29, x30, [sp, #0x10]    ; ldp :load pair ; 一对寄存器, 从内存读取数据到寄存器

STR X0, [SP, #0x8]         ；st:store,str:往内存中写数据（偏移值为正）; X0寄存器的数据传送到SP+0x8地址值指向的存储空间
STUR   w0, [x29, #-0x8]   ;往内存中写数据（偏移值为负）
STP  x29, x30, [sp, #0x10]    ;store pair，存放一对数据, 入栈指令

CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）
CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）
CMP  ;比较指令，相当于SUBS，影响程序状态寄存器CPSR 

B   ;跳转指令，可带条件跳转与cmp配合使用
BL  ;带返回的跳转指令， 返回地址保存到LR（X30）
BLR  ; 带返回的跳转指令，跳转到指令后边跟随寄存器中保存的地址(例：blr    x8 ;跳转到x8保存的地址中去执行)
RET   ;子程序返回指令，返回地址默认保存在LR（X30）
```

![](C:\Users\MarxICB\Desktop\pwn学习\1117042-b2c177c73a7b92a6.webp)

这里千万不要把指令集和64位寄存器概念搞混，还要再次强调，汇编指令与指令集不一定等价，汇编只是为了让人更方便看。

ARM指令包含4位的条件码列表：

| **操作码** | **条件码助记符**              | **标志** | **含义**           |
| ---------- | ----------------------------- | -------- | ------------------ |
| 0000       | EQ                            | Z=1      | 相等               |
| 0001       | NE(Not Equal)                 | Z=0      | 不相等             |
| 0010       | CS/HS(Carry Set/High or Same) | C=1      | 无符号数大于或等于 |
| 0011       | CC/LO(Carry Clear/LOwer)      | C=0      | 无符号数小于       |
| 0100       | MI(MInus)                     | N=1      | 负数               |
| 0101       | PL(PLus)                      | N=0      | 正数或零           |
| 0110       | VS(oVerflow set)              | V=1      | 溢出               |
| 0111       | VC(oVerflow clear)            | V=0      | 没有溢出           |
| 1000       | HI(HIgh)                      | C=1,Z=0  | 无符号数大于       |
| 1001       | LS(Lower or Same)             | C=0,Z=1  | 无符号数小于或等于 |
| 1010       | GE(Greater or Equal)          | N=V      | 有符号数大于或等于 |
| 1011       | LT(Less Than)                 | N!=V     | 有符号数小于       |
| 1100       | GT(Greater Than)              | Z=0,N=V  | 有符号数大于       |
| 1101       | LE(Less or Equal)             | Z=1,N!=V | 有符号数小于或等于 |
| 1110       | AL                            | 任何     | 无条件执行(默认)   |
| 1111       | NV                            | 任何     | 从不执行           |

例子：

![](C:\Users\MarxICB\Desktop\pwn学习\1117042-1da35ce35264be33.webp)

![](C:\Users\MarxICB\Desktop\pwn学习\1117042-a9de01a9d58fbd26.webp)

## 栈

![](C:\Users\MarxICB\Desktop\pwn学习\e3ae939d0b73d44dbcb44a33657770d7.png)

ARM64架构的函数栈布局的关键点如下。

1.所有的函数调用栈都会组成一个单链表。

2.每个栈由两个地址来构成这个链表，这两个地址都是64位宽的，并且它们都位于栈的底部。
	2.1 低地址存放：指向上一个栈帧（父函数的栈帧）的栈基地址FP，类似于链表的prev指针。本书把这个地址称为P_FP（Previous 	             	FP），以区别于处理器内部的FP寄存器。
	2.2 高地址存放：当前函数的返回地址，也就是进入该函数时LR的值，本书把这个地址称为P_LR（Previous LR）。

3.处理器的FP和SP寄存器相同。在函数执行时FP和SP寄存器会指向该函数栈空间的FP处，即栈底。

4.函数返回时，ARM64处理器先把栈中的P_LR的值载入当前LR寄存器，然后执行ret指令（对比一下x64，它们的差别还是有的）

